
{%extends "test_template.html" %}


{%block main %}
<script src='{{ url_for("static", filename="js/sigma.min.js") }}'></script>
<script src='{{ url_for("static", filename="js/settings.js") }}'></script>
<script src='{{ url_for("static", filename="js/sigma.layout.forceAtlas2.min.js") }}'></script>
<script src='{{ url_for("static", filename="js/sigma.parsers.json.min.js") }}'></script>
<script src='{{ url_for("static", filename="js/sigma.plugins.dragNodes.js") }}'></script>
<script src='{{ url_for("static", filename="js/renderers/sigma.renderers.svg.js") }}'></script>
<script src='{{ url_for("static", filename="js/renderers/sigma.canvas.edges.labels.def.js") }}'></script>
<script type=text/javascript src="{{ url_for('static', filename='jquery.js') }}"></script>

<style>
    #graph-container {
       width:100vh;
       height: 600px;
       margin: auto;
    }
    #container {
      width: 100%;
      height: auto;
      margin: auto;
    }
   </style>
<div id="container">
<div id="graph-container"></div>
</div>

<script>
var nodeCount = 0,
    idcount = 0,
    edgeCount = 0,
    edgeid = 0,
    s,
    maxNodes = 20,
    maxEdges = 50,
    g = {
        nodes: [],
        edges: []
    }

s = new sigma({
    graph: g,
    container: 'graph-container',
    renderers:[ {
        container: document.getElementById('graph-container'),
        type: 'canvas'
    }],
    settings: {
        doubleClickEnabled: false,
        minEdgeSize: 0.5,
        maxEdgeSize: 4,
        enableEdgeHovering: true,
        edgeHoverColor: 'edge',
        defaultEdgeHoverColor: '#000',
        edgeHoverSizeRatio: 1,
        edgeHoverExtremities: true,
    }
});

CreateGraphFromDatabase();

// ---------Testing function only---------
function test() {
    alert("s"+ s + "g" + g);
}
// ---------Testing function only---------
function update() {
    s.graph.nodes().forEach(function(n) {
        n.size = 34,
        n.color = '#000'
    });
    s.refresh();
}

// Save the graph positions of each marker in the database
function SaveGraph() {
    node_arr = s.graph.nodes()

    for(let i = 0; i < s.graph.nodes().length; i++) {
        http = new XMLHttpRequest();
        const query = {
            query: `mutation { 
	            UpdateMarker(id: "` + node_arr[i]["id"] + `", x: ` + node_arr[i]["x"] + `, y: ` + node_arr[i]["y"] + `) { 
                    id
                    x
                    y
                }
            }`
        }
        SendQuery(http, query);
    }
}


// Fetch markers from database via graphql 
function SendQuery(http, query) {
    const port = "4000";
    const url = "http://localhost:" + port

    http.open("POST", url);
    http.setRequestHeader("Content-Type", "application/json")
    http.responseType = 'json';
    http.send(JSON.stringify(query));
}

// Create a sigma js graph from existing markers in database
function CreateGraphFromDatabase() {
    http = new XMLHttpRequest();
    const query = {
        query: `{
            Marker {
                id
                x
                y
                neighbors {
                    id
                }
            }
        }`
    }
    SendQuery(http, query)

    http.onload = function() {
        markers = http.response

        for(let i = 0; i < markers["data"]["Marker"].length; i++) {
            g.nodes.push(s.graph.addNode({
                id: "" + markers["data"]["Marker"][i]["id"],
                label: 'Node ' + markers["data"]["Marker"][i]["id"],
                x: markers["data"]["Marker"][i]["x"],
                y: markers["data"]["Marker"][i]["y"],
                size: '8',
                color: '#666',

            }));
            idcount = idcount + 1;
            nodeCount = nodeCount + 1;
        }
        
        for(let i = 0; i < markers["data"]["Marker"].length; i++) {
            if (markers["data"]["Marker"][i]["neighbors"].length > 0) {
                for(let j = 0; j < markers["data"]["Marker"][i]["neighbors"].length; j++) {
                    g.edges.push(s.graph.addEdge({
                        id: "" + edgeid,
                        source: "" + markers["data"]["Marker"][i]["id"],
                        target: "" + markers["data"]["Marker"][i]["neighbors"][j]["id"],
                        size: '8',
                        color: '#ccc',
                        hover_color: '#000'
                    }));
                    edgeid = edgeid + 1;
                    edgeCount = edgeCount + 1;
                }
            }
        }

        console.log(s.graph.edges());
        console.log(s.graph.nodes());

        s.refresh();
    }
}

//Function to add node to graph
function AddNode() {
    // Fetch the static counter from the database
    http = new XMLHttpRequest();
    const query = {
        query: `{ 
            Static { 
                marker_counter
            }
        }`
    }
    SendQuery(http, query);

    http.onload = function() {
        marker_counter = http.response["data"]["Static"][0]["marker_counter"];

        g.nodes.push(s.graph.addNode({
            id: "" + (marker_counter + 1),
            label: 'Node ' + (marker_counter + 1),
            x: 2.0,
            y: 2.0,
            size: '8',
            color: '#666',

        }));
        idcount = idcount + 1;
        nodeCount = nodeCount + 1;
        
        // Adding a marker to the database
        http = new XMLHttpRequest();
        const query2 = {
            query: `mutation { 
                CreateMarker(id: ` + (marker_counter + 1) + `, x: 2.0, y: 5.0) { 
                    id
                }
            }`
        }
        SendQuery(http, query2)

        // Increment "marker_counter" attribute of "Static" node in neo4j
        http = new XMLHttpRequest();
        const query3 = {
            query: `mutation { 
                UpdateStatic(id: 0, marker_counter: ` + (marker_counter + 1) + `) { 
                    id
                }
            }`
        }
        SendQuery(http, query3)

        NodeOrEdgeEvent(0);

        console.log(s.graph.edges())
        s.refresh();
    }
}

// Add edge between nodes on graph. 
function AddEdge() {
    // Fetch the static counter from the database
    http = new XMLHttpRequest();
    const query = {
        query: `{ 
            Static { 
                relation_counter
            }
        }`
    }
    SendQuery(http, query);

    http.onload = function() {
        relation_counter = http.response["data"]["Static"][0]["relation_counter"];

        var fromNode = document.getElementById('value').value[0];
        var toNode = document.getElementById('value2').value[0];
        g.edges.push(s.graph.addEdge({
            id: "" + (relation_counter + 1),
            source: fromNode,
            target: toNode,
            size: '8',
            color: '#ccc',
            hover_color: '#000'
        }));
        edgeid = edgeid + 1;
        edgeCount = edgeCount + 1; 

        http = new XMLHttpRequest();
        const query2 = {
            query: `mutation { 
                AddMarkerNeighbors(from:{id: ` + fromNode + `}, to:{id: ` + toNode + `}) {
                    from{id}
                    to{id}
                }
            }`
        }
        SendQuery(http, query2);

        // Increment "relation_counter" attribute of "Static" node in neo4j
        http = new XMLHttpRequest();
        const query3 = {
            query: `mutation { 
                UpdateStatic(id: 0, relation_counter: ` + (relation_counter + 1) + `) { 
                    id
                }
            }`
        }
        SendQuery(http, query3)

        NodeOrEdgeEvent(1);

        s.refresh();
    }
}

function RemoveNode() {
    var nodeid = document.getElementById('value3').value[0];
    s.graph.dropNode(nodeid);
    nodeCount = nodeCount -1;

    http = new XMLHttpRequest();
    const query = {
        query: `mutation { 
            DeleteMarker(id: ` + (nodeid) + `) { 
                id
            }
        }`
    }
    SendQuery(http, query)

    NodeOrEdgeEvent(2);

    s.refresh();
}

function sendID() {
    var docsss = document.getElementById('list-id').innerHTML;
}
function RemoveEdge() {
    var edge_id = document.getElementById('value4').value[0];
    s.graph.dropEdge('e' + edge_id);
    edgeCount = edgeCount - 1;
    NodeOrEdgeEvent(3);

    s.refresh();
}

function ConfigureGateway() {
    http = new XMLHttpRequest();
    const port = "4000";
    const url = "http://localhost:" + port

    var gateway_uuid = document.getElementById('conf_gateway').value
    var marker_id = document.getElementById('conf_marker').value

    const query1 = {
        query: `mutation {
            AddMarkerGateway(from: {id: "` + marker_id + `"}, to: {uuid: "` + gateway_uuid + `"}) {
                    from {
                        id
                    }
                    to { 
                        uuid
                    }
                }  
            }`
    }

    http.open("POST", url);
    http.setRequestHeader("Content-Type", "application/json")
    http.responseType = 'json';
    http.send(JSON.stringify(query1));
    

    const query2 = {
        query: `mutation {
            AddGatewayMarker(from: {uuid: "` + gateway_uuid + `"}, to: {id: "` + marker_id + `"}) {
                    from {
                        uuid
                    }
                    to { 
                        id
                    }
                }  
            }`
    }

    http = new XMLHttpRequest();
    http.open("POST", url);
    http.setRequestHeader("Content-Type", "application/json")
    http.responseType = 'json';
    http.send(JSON.stringify(query2));

    SaveGraph();

    location.reload();
}

// Initialize the dragNodes plugin:
var dragListener = sigma.plugins.dragNodes(s, s.renderers[0]);

dragListener.bind('startdrag', function(event) {
console.log(event);
});
dragListener.bind('drag', function(event) {
console.log(event);
});
dragListener.bind('drop', function(event) {
console.log(event);
});
dragListener.bind('dragend', function(event) {
console.log(event);
});

s.bind('clickNode', function(e) {
  console.log(e.type, e.data.node.id);
  var nodeid = e.data.node.id;
});
s.bind('overEdge outEdge clickEdge doubleClickEdge rightClickEdge', function(e) {
  console.log(e.type, e.data.edge, e.data.captor);
});
s.bind('clickStage', function(e) {
  console.log(e.type, e.data.captor);
});
s.bind('doubleClickStage rightClickStage', function(e) {
  console.log(e.type, e.data.captor);
}); 
</script>

{% endblock %}